package buildLogic

import org.gradle.api.Project
import org.gradle.api.artifacts.Dependency
import org.gradle.api.tasks.testing.Test
import org.gradle.kotlin.dsl.dependencies
import org.gradle.kotlin.dsl.withType
import org.jetbrains.kotlin.gradle.dsl.KotlinBaseExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME
import org.jetbrains.kotlin.gradle.plugin.PLUGIN_CLASSPATH_CONFIGURATION_NAME
import org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask
import kotlin.io.path.Path
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.writeText

/**
 * Adds the configuration normally supplied by the project's own Gradle plugin.
 *
 * This enables the project's compiler plugin without loading it from a repository.
 */
fun Project.addTestBalloonPluginFromProject(compilerPluginDependency: Dependency, abstractionsDependency: Dependency) {
    dependencies {
        add(PLUGIN_CLASSPATH_CONFIGURATION_NAME, compilerPluginDependency)
        add(NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME, compilerPluginDependency)
        // WORKAROUND https://youtrack.jetbrains.com/issue/KT-53477 â€“ KGP misses transitive compiler plugin dependencies
        add(NATIVE_COMPILER_PLUGIN_CLASSPATH_CONFIGURATION_NAME, abstractionsDependency)
    }

    val testSourceSetNames = setOf("test", KotlinSourceSet.COMMON_TEST_SOURCE_SET_NAME)
    val generatedCommonTestDir = layout.buildDirectory.dir("generated/testBalloon/src/commonTest")

    extensions.configure<KotlinBaseExtension>("kotlin") {
        sourceSets.configureEach {
            if (name in testSourceSetNames) {
                kotlin.srcDir(generatedCommonTestDir)
            }
        }
    }

    val generateTestBalloonInitializationTask = tasks.register("generateTestBalloonInitialization") {
        outputs.dir(generatedCommonTestDir)
        doLast {
            val directory = Path("${generatedCommonTestDir.get()}/kotlin")
            check(directory.exists() || directory.toFile().mkdirs()) { "Could not create directory '$directory'" }
            (directory / "EntryPointAnchor.kt").writeText(
                """
                        package de.infix.testBalloon.framework.internal.entryPoint

                        // This file was generated by buildLogic/addTestBalloonPluginFromProject.kt.
                        // The compiler plugin will populate it with entry point code.

                """.trimIndent()
            )
        }
    }

    tasks.configureEach {
        if (this is KotlinCompilationTask<*> && name.contains("Test")) {
            dependsOn(generateTestBalloonInitializationTask)
        }
    }

    tasks.withType<Test>().configureEach {
        // https://docs.gradle.org/current/userguide/java_testing.html
        useJUnitPlatform()

        // Ask Gradle to skip scanning for test classes. We don't need it as our compiler plugin already
        // knows. Does this make a difference? I don't know.
        isScanForTestClasses = false

        // Pass TEST_* environment variables from the Gradle invocation to the test JVM.
        for ((name, value) in providers.environmentVariablesPrefixedBy("TEST_").get()) {
            environment(name, value)
        }

        // Pass TEST_* system properties as environment variables. NOTE: Doesn't help with K/Native.
        for ((name, value) in providers.systemPropertiesPrefixedBy("TEST_").get()) {
            environment(name, value)
        }
    }

    val testRuntimeOnlyConfigurations = setOf("testRuntimeOnly", "jvmTestRuntimeOnly")

    configurations.configureEach {
        if (name in testRuntimeOnlyConfigurations) {
            dependencies.add(
                project.dependencies.create(libraryFromCatalog("org.junit.platform.launcher"))
            )
        }
    }
}
