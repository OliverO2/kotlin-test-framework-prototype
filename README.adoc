:icons: font

== TestBalloon â€“ A coroutines-first Kotlin Multiplatform test framework

NOTE: Structured testing for Kotlin Multiplatform: Coroutines-powered, lightweight, easy to use

image:documentation/images/Test%20Run.png[Test Run.png]

=== How to Use TestBalloon

. Add the TestBalloon Gradle plugin to your build script:
+
[source,kotlin]
----
plugins {
    id("de.infix.testBalloon") version "VERSION"
}
----

. Add a dependency for the TestBalloon framework core library:
+
[source,kotlin]
----
commonTest {
    dependencies {
        implementation("de.infix.testBalloon:framework-core:VERSION")
    }
}
----

. Add the assertion library of your choice to the `commonTest` source set.
** For kotlin-test assertions:
+
[source,kotlin]
----
implementation(kotlin("test"))
----
** For Kotest assertions with support for soft assertion and clues:
+
[source,kotlin]
----
implementation("de.infix.testBalloon:integrations-kotest-assertions:VERSION")
----

. Write a test:
+
[source,kotlin]
----
val MyFirstTestSuite by testSuite {
    test("string length") {
        assertEquals(8, "Test me!".length)
    }
}
----

=== What to expect

==== Structured testing, unified multiplatform API

The TestBalloon DSL uses two central functions, `testSuite` and `test`. Test suites can nest on all platforms, including Kotlin/JS and Kotlin/Wasm.

The entire TestBalloon API resides in the `common` source set and supports all targets uniformly.

[source,kotlin]
----
val MyTestSuite by testSuite { <1>
    test("string length") { <2>
        assertEquals(8, "Test me!".length) <3>
    }

    testSuite("integer operations") { <4>
        test("max") {
            assertEquals(5, max(5, 3))
        }

        test("min") {
            delay(10.milliseconds) <5>
            assertEquals(3, min(5, 3))
        }
    }
}
----
<1> Define a top-level test suite.
<2> Define a test.
<3> Use the assertion library of your choice.
<4> Nest test suites.
<5> Use coroutines everywhere, in a `TestScope` by default.

==== Coroutines everywhere

When tests execute, each test suite becomes a coroutine, as does each test. These coroutines nest naturally, making it easy to inherit coroutine contexts and manage resource setup and tear-down (more on this later).

==== Dynamic tests in plain Kotlin

Inside the trailing lambdas of `testSuite` and `test`, you can use all Kotlin constructs (variable scopes, conditions, loops) to create tests dynamically. There is no extra dynamic/data/factory API you need to learn.

[source,kotlin]
----
include::examples/framework-core/src/commonTest/kotlin/com/example/DynamicTests.kt[lines=7..]
----

==== Fixtures

You can use fixtures for efficient, scoped shared state:

[source,kotlin]
----
val MyTestSuite by testSuite {
    val starRepository = fixture { <1>
        StarRepository() <2>
    } closeWith {
        disconnect() <3>
    }

    testSuite("actual users") {
        test("alina") {
            assertEquals(4, starRepository().userStars("alina")) <4>
        }

        test("peter") {
            assertEquals(3, starRepository().userStars("peter")) <5>
        }
    }
} <6>
----
<1> Declare a fixture at zero cost if not used.
<2> Use suspend functions in setup code.
<3> Use suspend functions in (optional) tear-down code.
<4> Use the fixture, which initializes lazily.
<5> Reuse the same fixture in other tests, sharing its setup cost.
<6> The fixture will close automatically when its suite finishes.

==== Extensible test DSL

You can use plain Kotlin to define your own types of tests and test suites, like this test variant with an `iterations` parameter:

[source,kotlin]
----
include::examples/framework-core/src/commonTest/kotlin/com/example/testLibrary/TestVariants.kt[lines=28..]
----

You can also use Kotlin-tailored mechanisms to easily augment suites and tests, e.g. with setup and tear-down code, and wrappers like `withTimeout`.

* xref:examples/framework-core/src/commonTest/kotlin/com/example/UsingAroundAll.kt[`aroundAll`] wraps a lambda around an entire test suite.
* xref:examples/framework-core/src/commonTest/kotlin/com/example/UsingAroundEach.kt[`aroundEach`] wraps a lambda around each test of a test suite (including those in child suites).

==== User-friendly, extensible configuration API

You can configure your tests or test suites through a unified, small-surface API (the `TestConfig` builder). You can extend the API with custom configurations.

[source,kotlin]
----
configuration = TestConfig
    .invocation(TestInvocation.CONCURRENT) <1>
    .coroutineContext(dispatcherWithParallelism(4)) <2>
    .statisticsReport() <3>
----
<1> Use concurrent test execution instead of the sequential default.
<2> Parallelize as needed (and the platform supports).
<3> A custom configuration for extra reporting

==== Global configuration, familiar API

You can declare a `TestSession` class, defining the global configuration with the `TestConfig` builder.

To run some test suites in isolation, and/or provide them with special configuration, you can use
``TestCompartment``s. These group top-level test suites, with each compartment running in isolation.

`TestSession` and ``TestCompartment``s are just special types of ``TestSuite``s and use the same API for configuration.

==== Lightweight, maintainable

TestBalloon has a fully platform-independent API (everything is in the `common` source set) and almost zero redundancy in its platform-specific parts. Though powerful, its architecture favors simplicity and aims to avoid implicit constructs and indirection, for viable long-term maintainability.

=== Examples and documentation

Find examples demonstrating TestBalloon's capabilities in xref:examples/framework-core[], and an example showing how to use TestBalloon with Kotest assertions in xref:examples/integration-kotest-assertions[].

The TestBalloon public API includes source code documentation.

=== More Information

Please familiarize yourself with TestBalloon's xref:documentation/Limitations.adoc[limitations].

If you'd like to know why and how TestBalloon came to life, read about its xref:documentation/Background.adoc[background].

If you are wondering why TestBalloon works the way it does, read about its xref:documentation/Design Considerations.adoc[design considerations].

Finally, there is a brief xref:documentation/Development.adoc[introduction to development].

=== TODO

* [ ] Prepare publication
** [ ] Versioning
** [x] License file, Copyright notices
* [ ] Rename `TestConfig` to `Operation` or `Operator` (like `Modifier` but avoiding a clash with Compose)?
* [ ] Rename `TestElement` properties to `test*`, reducing scope pollution? What about `fixture`?
* [ ] Document IDE plugin installation.
* [ ] IDE plugin: Provide a https://plugins.jetbrains.com/docs/intellij/structure-view-factory.html[structure view] for tests.
