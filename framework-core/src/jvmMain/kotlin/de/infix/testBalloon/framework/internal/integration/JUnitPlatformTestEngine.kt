package de.infix.testBalloon.framework.internal.integration

import de.infix.testBalloon.framework.AbstractTestSuite
import de.infix.testBalloon.framework.FailFastException
import de.infix.testBalloon.framework.Test
import de.infix.testBalloon.framework.TestCompartment
import de.infix.testBalloon.framework.TestElement
import de.infix.testBalloon.framework.TestElementEvent
import de.infix.testBalloon.framework.TestReport
import de.infix.testBalloon.framework.TestSession
import de.infix.testBalloon.framework.TestSuite
import de.infix.testBalloon.framework.internal.EnvironmentBasedElementSelection
import de.infix.testBalloon.framework.internal.TestFrameworkDiscoveryResult
import de.infix.testBalloon.framework.internal.logDebug
import io.github.classgraph.ClassGraph
import io.github.classgraph.ScanResult
import kotlinx.coroutines.runBlocking
import org.junit.platform.engine.EngineDiscoveryRequest
import org.junit.platform.engine.ExecutionRequest
import org.junit.platform.engine.TestDescriptor
import org.junit.platform.engine.TestEngine
import org.junit.platform.engine.TestExecutionResult
import org.junit.platform.engine.TestSource
import org.junit.platform.engine.UniqueId
import org.junit.platform.engine.support.descriptor.AbstractTestDescriptor
import org.junit.platform.engine.support.descriptor.ClassSource
import org.junit.platform.engine.support.descriptor.EngineDescriptor
import java.util.concurrent.ConcurrentHashMap

private var topLevelTestSuites = setOf<AbstractTestSuite>()
private val testElementDescriptors = ConcurrentHashMap<TestElement, AbstractTestDescriptor>()

/**
 * The [TestEngine] interfacing with JUnit Platform (JVM only).
 *
 * This class is registered via the `ServiceLoader` mechanism with a provider configuration file on the classpath.
 * JUnit Platform will instantiate it and invoke its methods.
 */
internal class JUnitPlatformTestEngine : TestEngine {
    override fun getId(): String = "de.infix.testBalloon"

    override fun discover(discoveryRequest: EngineDiscoveryRequest, uniqueId: UniqueId): TestDescriptor {
        // We use the framework's compiler plugin to discover tests. That means we are ignoring the
        // discoveryRequest's selectors and filters.

        // Find the file-level class containing the framework's discovery result property. This property has
        // (hopefully) been generated by the framework's compiler plugin, but, unfortunately, we don't know
        // in which "source file". (The plugin needs to use one of the existing source files.)
        val frameworkDiscoveryResultPropertyGetterName = "getTestFrameworkDiscoveryResult"
        val frameworkDiscoveryResultFileClass = withClassGraphScan {
            allClasses
                .asSequence()
                .firstOrNull {
                    it.name.endsWith("Kt") && it.getMethodInfo(frameworkDiscoveryResultPropertyGetterName) != null
                }
        }?.let { Class.forName(it.name) }

        // If no discovery result property was found, return early, avoiding any initialization.
        if (frameworkDiscoveryResultFileClass == null) {
            // Do not initialize the test framework if no test classes have been discovered on the classpath.
            // This is probably a JVM-standalone invocation via the main() function for testing.
            return EngineDescriptor(UniqueId.forEngine(id), "${this::class.qualifiedName}")
        }

        val frameworkDiscoveryResult = try {
            frameworkDiscoveryResultFileClass.getMethod(frameworkDiscoveryResultPropertyGetterName).invoke(null)
                as TestFrameworkDiscoveryResult
        } catch (throwable: Throwable) {
            throw IllegalArgumentException(
                "Could not access the test discovery result." +
                    " Please ensure that the correct version of the framework's compiler plugin was applied.",
                throwable
            )
        }

        topLevelTestSuites = frameworkDiscoveryResult.topLevelTestSuites.toSet()

        TestSession.global.parameterize(
            EnvironmentBasedElementSelection(System.getenv("TEST_INCLUDE"), System.getenv("TEST_EXCLUDE"))
        )

        val engineDescriptor = EngineDescriptor(UniqueId.forEngine(id), "${this::class.qualifiedName}")
        log { "created EngineDescriptor(${engineDescriptor.uniqueId}, ${engineDescriptor.displayName})" }
        testElementDescriptors[TestSession.global] = engineDescriptor
        engineDescriptor.addChild(TestSession.global.newPlatformDescriptor(uniqueId))

        return engineDescriptor
    }

    override fun execute(request: ExecutionRequest) {
        if (topLevelTestSuites.isEmpty()) {
            // No tests were discovered. This is typically the case if the framework has been included
            // as a dependency, but another test framework is in charge. Make sure we don't report anything
            // to JUnit Platform's listener, otherwise JUnit Platform will complain.
            return
        }

        val jUnitListener = request.engineExecutionListener

        runBlocking {
            TestSession.global.execute(
                report = object : TestReport() {
                    // A TestReport relaying each TestElementEvent to the JUnit listener.

                    override suspend fun add(event: TestElementEvent) {
                        when (event) {
                            is TestElementEvent.Starting -> {
                                if (event.element.isEnabled) {
                                    log { "${event.element.platformDescriptor}: ${event.element} starting" }
                                    jUnitListener.executionStarted(event.element.platformDescriptor)
                                } else {
                                    if (event.element.parentSuite?.isEnabled == true) {
                                        // Report skipping only if it has not already been reported by a parent.
                                        // (Report nothing if this is the disabled root element.)
                                        log { "${event.element.platformDescriptor}: ${event.element} skipped" }
                                        jUnitListener.executionSkipped(event.element.platformDescriptor, "disabled")
                                    }
                                }
                            }

                            is TestElementEvent.Finished -> {
                                if (event.element.isEnabled) {
                                    log {
                                        "${event.element.platformDescriptor}: ${event.element} finished," +
                                            " result=${event.executionResult})"
                                    }
                                    jUnitListener.executionFinished(
                                        event.element.platformDescriptor,
                                        event.executionResult
                                    )
                                }
                            }
                        }
                    }
                }
            )
        }
    }
}

private class TestElementJUnitPlatformDescriptor(
    uniqueId: UniqueId,
    displayName: String,
    source: TestSource?,
    val element: TestElement
) : AbstractTestDescriptor(uniqueId, displayName, source) {
    override fun getType(): TestDescriptor.Type = when (element) {
        is Test -> TestDescriptor.Type.TEST
        is TestSuite -> TestDescriptor.Type.CONTAINER
    }

    override fun toString(): String = "PD(uId=$uniqueId, dN=\"$displayName\", t=$type)"
}

private fun TestElement.newPlatformDescriptor(parentUniqueId: UniqueId): TestElementJUnitPlatformDescriptor {
    val uniqueId: UniqueId
    val element = this
    var source: TestSource? = null

    val segmentType = when (element) {
        is Test -> "test"
        is TestSession -> "session"
        is TestCompartment -> "compartment"
        is TestSuite -> {
            if (topLevelTestSuites.contains(element)) {
                source = ClassSource.from(elementName)
                "class"
            } else {
                "suite"
            }
        }
    }
    uniqueId = parentUniqueId.append(segmentType, elementName)

    return TestElementJUnitPlatformDescriptor(
        uniqueId = uniqueId,
        displayName = displayName,
        source = source,
        element = element
    ).apply {
        log { "created TestDescriptor($uniqueId, $displayName)" }
        testElementDescriptors[element] = this
        if (this@newPlatformDescriptor is TestSuite) {
            childElements.forEach { addChild(it.newPlatformDescriptor(uniqueId)) }
        }
    }
}

private val TestElement.platformDescriptor: AbstractTestDescriptor get() =
    checkNotNull(testElementDescriptors[this]) { "$this is missing its TestDescriptor" }

private val TestElementEvent.Finished.executionResult: TestExecutionResult get() =
    when (throwable) {
        null -> TestExecutionResult.successful()
        is FailFastException -> TestExecutionResult.aborted(throwable)
        else -> TestExecutionResult.failed(throwable)
    }

private fun <Result> withClassGraphScan(action: ScanResult.() -> Result): Result = ClassGraph()
    .disableJarScanning()
    .disableModuleScanning()
    .disableNestedJarScanning()
    .enableMethodInfo()
    .scan().use { scanResult ->
        scanResult.action()
    }

private fun log(message: () -> String) {
    logDebug(message)
}
